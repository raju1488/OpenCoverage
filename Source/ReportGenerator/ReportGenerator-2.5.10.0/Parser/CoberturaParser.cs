using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Threading.Tasks;
using System.Xml.Linq;
using Palmmedia.ReportGenerator.Logging;
using Palmmedia.ReportGenerator.Parser.Analysis;
using Palmmedia.ReportGenerator.Properties;

namespace Palmmedia.ReportGenerator.Parser
{
    /// <summary>
    /// Parser for XML reports generated by Cobertura.
    /// </summary>
    internal class CoberturaParser : ParserBase
    {
        /// <summary>
        /// The Logger.
        /// </summary>
        private static readonly ILogger Logger = LoggerFactory.GetLogger(typeof(CoberturaParser));

        /// <summary>
        /// The module elements of the report.
        /// </summary>
        private XElement[] modules;

        /// <summary>
        /// Initializes a new instance of the <see cref="CoberturaParser"/> class.
        /// </summary>
        /// <param name="report">The report file as XContainer.</param>
        internal CoberturaParser(XContainer report)
        {
            if (report == null)
            {
                throw new ArgumentNullException(nameof(report));
            }

            this.modules = report.Descendants("package")
                .ToArray();

            var assemblyNames = this.modules
                .Select(m => m.Attribute("name").Value)
                .Distinct()
                .OrderBy(a => a)
                .ToArray();

            Parallel.ForEach(assemblyNames, assemblyName => this.AddAssembly(this.ProcessAssembly(assemblyName)));

            this.modules = null;
        }

        /// <summary>
        /// Gets a value indicating whether the used parser supports branch coverage.
        /// </summary>
        /// <value>
        /// <c>true</c> if used parser supports branch coverage; otherwise, <c>false</c>.
        /// </value>
        public override bool SupportsBranchCoverage => true;

        /// <summary>
        /// Extracts the metrics from the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="methods">The methods.</param>
        /// <param name="class">The class.</param>
        private static void SetMethodMetrics(IEnumerable<XElement> methods, Class @class)
        {
            foreach (var method in methods)
            {
                string methodName = method.Attribute("name").Value + method.Attribute("signature").Value;

                var metrics = new List<Metric>();

                var lineRate = method.Attribute("line-rate");

                if (lineRate != null)
                {
                    metrics.Add(new Metric(
                        ReportResources.Coverage,
                        ParserBase.CodeCoverageUri,
                        Math.Round(decimal.Parse(lineRate.Value, CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero)));
                }

                var branchRate = method.Attribute("branch-rate");

                if (branchRate != null)
                {
                    metrics.Add(new Metric(
                        ReportResources.BranchCoverage,
                        ParserBase.CodeCoverageUri,
                        Math.Round(decimal.Parse(branchRate.Value, CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero)));
                }

                var cyclomaticComplexityAttribute = method.Attribute("complexity");

                if (cyclomaticComplexityAttribute != null)
                {
                    metrics.Insert(
                        0,
                        new Metric(
                        ReportResources.CyclomaticComplexity,
                        ParserBase.CyclomaticComplexityUri,
                         Math.Round(decimal.Parse(cyclomaticComplexityAttribute.Value, CultureInfo.InvariantCulture), 2, MidpointRounding.AwayFromZero)));
                }

                @class.AddMethodMetric(new MethodMetric(methodName, metrics));
            }
        }

        /// <summary>
        /// Gets the branches by line number.
        /// </summary>
        /// <param name="lines">The lines.</param>
        /// <returns>The branches by line number.</returns>
        private static Dictionary<int, ICollection<Branch>> GetBranches(IEnumerable<XElement> lines)
        {
            var result = new Dictionary<int, ICollection<Branch>>();

            var branchPoints = lines
                .Elements("conditions")
                .Elements("condition")
                .ToArray();

            foreach (var branchPoint in branchPoints)
            {
                int lineNumber = int.Parse(branchPoint.Parent.Parent.Attribute("number").Value, CultureInfo.InvariantCulture);

                string identifier = string.Format(
                    CultureInfo.InvariantCulture,
                    "{0}_{1}",
                    lineNumber,
                    branchPoint.Attribute("number").Value);

                var branch = new Branch(
                    branchPoint.Attribute("coverage").Value.Equals("0%") ? 0 : 1,
                    identifier);

                ICollection<Branch> branches = null;
                if (result.TryGetValue(lineNumber, out branches))
                {
                    HashSet<Branch> branchesHashset = (HashSet<Branch>)branches;
                    if (branchesHashset.Contains(branch))
                    {
                        // Not perfect for performance, but Hashset has no GetElement method
                        branchesHashset.First(b => b.Equals(branch)).BranchVisits += branch.BranchVisits;
                    }
                    else
                    {
                        branches.Add(branch);
                    }
                }
                else
                {
                    branches = new HashSet<Branch>();
                    branches.Add(branch);

                    result.Add(lineNumber, branches);
                }
            }

            return result;
        }

        /// <summary>
        /// Extracts the methods/properties of the given <see cref="XElement">XElements</see>.
        /// </summary>
        /// <param name="codeFile">The code file.</param>
        /// <param name="methodsOfFile">The methods of the file.</param>
        private static void SetCodeElements(CodeFile codeFile, IEnumerable<XElement> methodsOfFile)
        {
            foreach (var method in methodsOfFile)
            {
                string methodName = method.Attribute("name").Value + method.Attribute("signature").Value;

                var line = method.Elements("lines")
                    .Elements("line")
                    .FirstOrDefault();

                if (line != null)
                {
                    int lineNumber = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture);
                    codeFile.AddCodeElement(new CodeElement(methodName, CodeElementType.Method, lineNumber));
                }
            }
        }

        /// <summary>
        /// Processes the given assembly.
        /// </summary>
        /// <param name="assemblyName">Name of the assembly.</param>
        /// <returns>The <see cref="Assembly"/>.</returns>
        private Assembly ProcessAssembly(string assemblyName)
        {
            Logger.DebugFormat("  " + Resources.CurrentAssembly, assemblyName);

            var classNames = this.modules
                .Where(m => m.Attribute("name").Value.Equals(assemblyName))
                .Elements("classes")
                .Elements("class")
                .Select(c => c.Attribute("name").Value)
                .Where(c => !c.Contains("$"))
                .Distinct()
                .OrderBy(name => name)
                .ToArray();

            var assembly = new Assembly(assemblyName);

            Parallel.ForEach(classNames, className => assembly.AddClass(this.ProcessClass(assembly, className)));

            return assembly;
        }

        /// <summary>
        /// Processes the given class.
        /// </summary>
        /// <param name="assembly">The assembly.</param>
        /// <param name="className">Name of the class.</param>
        /// <returns>The <see cref="Class"/>.</returns>
        private Class ProcessClass(Assembly assembly, string className)
        {
            var files = this.modules
                .Where(m => m.Attribute("name").Value.Equals(assembly.Name))
                .Elements("classes")
                .Elements("class")
                .Where(c => c.Attribute("name").Value.Equals(className))
                .Select(c => c.Attribute("filename").Value)
                .Distinct()
                .ToArray();

            var @class = new Class(className, assembly);

            foreach (var file in files)
            {
                @class.AddFile(this.ProcessFile(@class, file));
            }

            return @class;
        }

        /// <summary>
        /// Processes the file.
        /// </summary>
        /// <param name="class">The class.</param>
        /// <param name="filePath">The file path.</param>
        /// <returns>The <see cref="CodeFile"/>.</returns>
        private CodeFile ProcessFile(Class @class, string filePath)
        {
            var classes = this.modules
                .Where(m => m.Attribute("name").Value.Equals(@class.Assembly.Name))
                .Elements("classes")
                .Elements("class")
                .Where(c => c.Attribute("name").Value.Equals(@class.Name)
                            || c.Attribute("name").Value.StartsWith(@class.Name + "$", StringComparison.Ordinal))
                .ToArray();

            var methodsOfFile = classes
                .Elements("methods")
                .Elements("method")
                .ToArray();

            SetMethodMetrics(methodsOfFile, @class);

            var lines = classes.Elements("lines")
                .Elements("line")
                .ToArray();

            var linesOfFile = lines
                .Select(line => new
                {
                    LineNumber = int.Parse(line.Attribute("number").Value, CultureInfo.InvariantCulture),
                    Visits = int.Parse(line.Attribute("hits").Value, CultureInfo.InvariantCulture)
                })
                .OrderBy(seqpnt => seqpnt.LineNumber)
                .ToArray();

            var branches = GetBranches(lines);

            int[] coverage = new int[] { };
            LineVisitStatus[] lineVisitStatus = new LineVisitStatus[] { };

            if (linesOfFile.Length > 0)
            {
                coverage = new int[linesOfFile[linesOfFile.LongLength - 1].LineNumber + 1];
                lineVisitStatus = new LineVisitStatus[linesOfFile[linesOfFile.LongLength - 1].LineNumber + 1];

                for (int i = 0; i < coverage.Length; i++)
                {
                    coverage[i] = -1;
                }

                foreach (var line in linesOfFile)
                {
                    coverage[line.LineNumber] = line.Visits;

                    bool partiallyCovered = false;

                    ICollection<Branch> branchesOfLine = null;
                    if (branches.TryGetValue(line.LineNumber, out branchesOfLine))
                    {
                        partiallyCovered = branchesOfLine.Any(b => b.BranchVisits == 0);
                    }

                    LineVisitStatus statusOfLine = line.Visits > 0 ? (partiallyCovered ? LineVisitStatus.PartiallyCovered : LineVisitStatus.Covered) : LineVisitStatus.NotCovered;
                    lineVisitStatus[line.LineNumber] = statusOfLine;
                }
            }

            var codeFile = new CodeFile(filePath, coverage, lineVisitStatus, branches);

            SetCodeElements(codeFile, methodsOfFile);

            return codeFile;
        }
    }
}
